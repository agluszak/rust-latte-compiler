use std::str::FromStr;
use crate::lexer::Spanned;
use crate::ast::*;
use crate::lexer2;
use logos::Logos;

grammar<'input>;

pub Program: Program = Spanned<Decl>* => Program(<>);

extern {
    type Location = usize;
    type Error = ();

    enum lexer2::Token<'input> {
        "true" => lexer2::Token::True,
        "false" => lexer2::Token::False,
        "num" => lexer2::Token::Num(<i64>),
        "str" => lexer2::Token::Str(<&'input str>),
        "ident" => lexer2::Token::Ident(<&'input str>),
        "if" => lexer2::Token::If,
        "else" => lexer2::Token::Else,
        "while" => lexer2::Token::While,
        "return" => lexer2::Token::Return,
        "{" => lexer2::Token::LBrace,
        "}" => lexer2::Token::RBrace,
        "(" => lexer2::Token::LParen,
        ")" => lexer2::Token::RParen,
        "[" => lexer2::Token::LBracket,
        "]" => lexer2::Token::RBracket,
        "," => lexer2::Token::Comma,
        ";" => lexer2::Token::Semicolon,
        "+" => lexer2::Token::Plus,
        "-" => lexer2::Token::Minus,
        "*" => lexer2::Token::Star,
        "/" => lexer2::Token::Slash,
        "%" => lexer2::Token::Percent,
        "!" => lexer2::Token::Bang,
        "=" => lexer2::Token::Equal,
        "==" => lexer2::Token::EqualEqual,
        "!=" => lexer2::Token::BangEqual,
        "<" => lexer2::Token::Less,
        "<=" => lexer2::Token::LessEqual,
        ">" => lexer2::Token::Greater,
        ">=" => lexer2::Token::GreaterEqual,
        "&&" => lexer2::Token::AmpersandAmpersand,
        "||" => lexer2::Token::PipePipe,
        "++" => lexer2::Token::PlusPlus,
        "--" => lexer2::Token::MinusMinus,
    }

}

Comma<Rule>: Vec<Rule> = {
    <mut v:(<Rule> ",")*> <e:Rule?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

CommaNonEmpty<Rule>: Vec<Rule> = {
    <mut v:(<Rule> ",")*> <e:Rule> => {
        v.push(e);
        v
    }
};

Spanned<Rule>: Spanned<Rule> =
    <l: @L> <rule: Rule> <r: @R> =>
        Spanned::new(l..r, rule);


Type: Type = <s:"ident"> => Type(s.to_string());

Ident: Ident = <s:"ident"> => Ident(s.to_string());

Block: Block = "{" <stmts: Spanned<Stmt>*> "}" => Block(stmts);

Item: Item = {
    <ident:Spanned<Ident>> "=" <e:Spanned<Expr>> => Item {
          ident,
          init: Some(e),
     },
    <ident:Spanned<Ident>> => Item {
          ident,
          init: None,
     },
};

Arg: Arg = <ty:Spanned<Type>> <name:Spanned<Ident>> => Arg { ty, name };

Decl: Decl = {
    <ty: Spanned<Type>> <items: CommaNonEmpty<Spanned<Item>>> ";" => Decl::Var {
        ty,
        items,
    },
    <return_type: Spanned<Type>> <name: Spanned<Ident>> "(" <args: Comma<Spanned<Arg>>> ")" <body: Spanned<Block>> => Decl::Fn {
          return_type,
          name,
          args,
          body,
     },
};

Stmt = Stmt_<"I">; // Handle dangling elses

Stmt_<I>: Stmt = {
    ";" => Stmt::Empty,
    <b:Spanned<Block>> => Stmt::Block(b),
    <d:Spanned<Decl>> => Stmt::Decl(d),
    <target:Spanned<Ident>> "=" <expr:Spanned<Expr>> ";" => Stmt::Assignment { target, expr },
    "return" <expr:Spanned<Expr>> ";" => Stmt::Return(Some(expr)),
    "return" ";" => Stmt::Return(None),
    "if" "(" <cond:Spanned<Expr>> ")" <then:Spanned<Stmt_<"I">>> if I != "" => Stmt::If { cond, then: Box::new(then), otherwise: None },
    "if" "(" <cond:Spanned<Expr>> ")" <then:Spanned<Stmt_<"">>> "else" <otherwise:Spanned<Stmt_<I>>> =>
         Stmt::If { cond, then: Box::new(then), otherwise: Some(Box::new(otherwise)) },
    "while" "(" <cond:Spanned<Expr>> ")" <body:Spanned<Stmt_<I>>> => Stmt::While { cond, body: Box::new(body) },
    <e:Spanned<Expr>> ";" => Stmt::Expr(e),
    <target:Spanned<Expr>> "++" => Stmt::Incr(target),
    <target:Spanned<Expr>> "--" => Stmt::Decr(target),

};

BinaryTier<Op, NextTier>: Expr = {
    <lhs:Spanned<BinaryTier<Op, NextTier>>> <op:Spanned<Op>> <rhs:Spanned<NextTier>> => Expr::Binary {
          op,
          lhs: Box::new(lhs),
          rhs: Box::new(rhs),
     },
    <e:NextTier> => e
};

UnaryTier<NextTier>: Expr = {
    <op:Spanned<UnaryOp>> <e:Spanned<UnaryTier<NextTier>>> => Expr::Unary { op, expr: Box::new(e) },
    <e:NextTier> => e,
};

Expr = LogicalOr;
LogicalOr = BinaryTier<LogicalOrOp, LogicalAnd>;
LogicalAnd = BinaryTier<LogicalAndOp, Comparison>;
Comparison = BinaryTier<ComparisonOp, Sum>;
Sum = BinaryTier<SumOp, Product>;
Product = BinaryTier<ProductOp, Unary>;
Unary = UnaryTier<Term>;

UnaryOp: UnaryOp = {
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
};

ProductOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
};

SumOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

ComparisonOp: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Lte,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Gte,
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Neq,
};

LogicalAndOp: BinaryOp = {
    "&&" => BinaryOp::And,
};

LogicalOrOp: BinaryOp = {
    "||" => BinaryOp::Or,
};

Literal: Literal = {
    <i:"num"> => Literal::Int(i),
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    <s:"str"> => Literal::String(s.to_string()),
};

Term: Expr = {
    <i:Ident> => Expr::Variable(i),
    <l:Literal> => Expr::Literal(l),
    <target:Spanned<Term>> "(" <args:Comma<Spanned<Expr>>> ")" => Expr::Application { target: Box::new(target), args },
    "(" <e:Expr> ")" => e,
};

// Handle escaped chars
String: String = <s:"str"> => {
    let mut result = String::new();
    let mut chars = s.chars();
    while let Some(c) = chars.next() {
        if c == '\\' {
            match chars.next() {
                Some('n') => result.push('\n'),
                Some('r') => result.push('\r'),
                Some('t') => result.push('\t'),
                Some('b') => result.push('\x08'),
                Some('f') => result.push('\x0c'),
                Some('\'') => result.push('\''),
                Some('\"') => result.push('\"'),
                Some('\\') => result.push('\\'),
                Some('u') => {
                    let mut code = 0;
                    for _ in 0..4 {
                        code = code * 16 + match chars.next() {
                            Some('0') => 0,
                            Some('1') => 1,
                            Some('2') => 2,
                            Some('3') => 3,
                            Some('4') => 4,
                            Some('5') => 5,
                            Some('6') => 6,
                            Some('7') => 7,
                            Some('8') => 8,
                            Some('9') => 9,
                            Some('a') | Some('A') => 10,
                            Some('b') | Some('B') => 11,
                            Some('c') | Some('C') => 12,
                            Some('d') | Some('D') => 13,
                            Some('e') | Some('E') => 14,
                            Some('f') | Some('F') => 15,
                            _ => panic!("Invalid unicode escape"),
                        };
                    }
                    result.push(std::char::from_u32(code).unwrap());
                },
                _ => panic!("Invalid escape"),
            }
        } else {
            result.push(c);
        }
    }
    result
};
